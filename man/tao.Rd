% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/tao.R
\name{tao}
\alias{tao}
\title{R bindings for the TAO optimization library.}
\usage{
tao(par, fn, gr = NULL, hs = NULL, method = c("lmvm", "nls", "ntr", "ntl",
  "cg", "tron", "blmvm", "gpcg", "nm", "pounders"), control = list(), n = 1,
  lb = NULL, ub = NULL)
}
\arguments{
\item{par}{Initial values for the parameters to be optimized over.}

\item{fn}{A function to be minimized (or maximized), with first argument
the vector of parameters over which minimization is to take place.
It should return a scalar result.}

\item{gr}{A function to return the gradient, if using a gradient-based
optimization method.}

\item{hs}{A function to return the hessian, if using an algorithm which
uses the hessian.}

\item{method}{The method to be used. See 'Details'.}

\item{control}{A list of control parameters. See 'Details'.}

\item{n}{The number of elements of objfun.}

\item{lb}{A vector with lower variable bounds (optional)}

\item{ub}{A vector with upper variable bounds (optional)}
}
\value{
A list with final parameter values, the objective function, and
       information on why the optimizer stopped.
}
\description{
Various optimization routines from the TAO optimization library. See
the TAO documentation for a complete listing.
}
\examples{
# Gradient-free method
objfun = function(x) c((x[1] - 3), (x[2] + 1))
ret = tao(c(1, 2),
                objfun,
                method = "pounders",
                control = list(tao_pounders_delta="0.1"),
                n = 2)
ret$x

# Gradient-based method: Limited memory variable metric method
objfun = function(x) (x[1] - 3)^2 + (x[2] + 1)^2
grafun = function(x) c(2*(x[1] - 3), 2*(x[2] + 1))

ret = tao(c(1, 2),
                objfun,
                gr = grafun,
                method = "lmvm")
ret$x

# Gradient-based method: Limited memory variable metric method with bounds
objfun = function(x) (x[1] - 3)^2 + (x[2] + 1)^2
grafun = function(x) c(2*(x[1] - 3), 2*(x[2] + 1))
inequal = function(x) c(x[1] - 2, x[2] - 2)

ret = tao(c(1, 2),
                objfun,
                gr = grafun,
                method = "blmvm")
ret$x

# Hessian (Newton Trust Region)
objfun = function(x) (x[1] - 3)^2 + (x[2] + 1)^2
grafun = function(x) c(2*(x[1] - 3), 2*(x[2] + 1))
hesfun = function(x) matrix(c(2, 0, 0, 2), nrow = 2, ncol = 2)

ret = tao(c(1, 2),
                objfun,
                gr = grafun,
                hs = hesfun,
                method = "ntr")
ret$x
}

